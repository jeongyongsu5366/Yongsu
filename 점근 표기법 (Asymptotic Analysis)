효율적인 알고리즘 = 문제를 빨리 해결하는 알고리즘

프로그램 속도에 영향을 주는 것들
- 컴퓨터의 사양
- 컴퓨터의 상태 (현재 사용량)
- 프로그래밍 언어
- 컴파일러
....
단순히 "시간"으로 알고리즘을 비교하는 것은 어렵다.

어떻게 알고리즘의 효율성을 평가해야하나?
인풋이 커질수록 얼마나 더 오래 걸리는가?

예) 라스트의 길이가 100배가 되면, 프로그램은 얼마나 더 걸리는가? (정렬 알고리즘 판단할때)

 a def linear_search(element, some_list):
 b     i = 0
       n = len(some_list)
    
 c     while i < n:
 d         if some_list[i] == element:
 d             return i
 d         i = i + 1
    
 e     return - 1
 
 
 a = 첫 번째 줄이 걸리는 시간
 b = 두 번째 줄이 걸리는 시간
 ...
 
 총 걸리는 시간: a + b + (n + 1) * c + n * d + e  = (c + d) * n + (a + b + c + e)
                                                      p            q
                                                      
p = 20 q = 40 이라 가정
n (리스트 길이)               20n + 40 (걸리는 시간)
1                               60
2                               80
3                               100
10                              240
100                             2040
10000                           200040     (가면 갈 수록 걸리는 시간에서의 40이 큰 역할을 하지 않는다)

인풋 크기(n)이 작으면 어차피 알고리즘은 빨리 돌아갑니다.
따라서, 알고리즘 분석을 할 때 n이 아주 크다고 가정하세요
알고리즘을 분석할 때 큰 영향력이 없는 40과 같은 것을 버린다
                              이렇게 큰 영향력이 없는 숫자를 다 제거해 표기하는 것을 점근 표기법(Big-O)
20n + 40 --> 20n          --> n --> O(N)       it is called big O of n
2n^2 + 8n + 157 --> 2n^2    --> n^2  --> O(n^2) it is called big O of n^2
n^3 + 15n^2 + n + 394 --> n^3  --> O(n^3)       it is called big O of n^3

O(n) => n(input) 2배가 되면, 걸리는 시간도 약 2배
리스트 크기             소요 시간
100                    1
200                    2
1000                   10

O(n^2) => n(input) 2배가 되면, 걸리는 시간은 약 4배
리스트 크기             소요 시간
100                    1                      
200                    4                       
1000                   100                     

O(n^3) => n(input) 2배가 되면, 걸리는 시간은 약 8배
리스트 크기             소요 시간
100                    1
200                    8
1000                   1000
